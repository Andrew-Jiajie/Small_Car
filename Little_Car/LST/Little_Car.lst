C51 COMPILER V9.53.0.0   LITTLE_CAR                                                        06/21/2018 21:33:24 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE LITTLE_CAR
OBJECT MODULE PLACED IN .\Output\Little_Car.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Code\Little_Car.C LARGE OPTIMIZE(4,SPEED) BROWSE INCDIR(..\Include) DEFI
                    -NE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\Little_Car.lst) TABS(2) OBJECT(.\Output\Little_Car.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* Copyright(c) 2017 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   4          /*                                                                                                        
             - */
   5          /*--------------------------------------------------------------------------------------------------------
             --*/
   6          
   7          //********************************************************************************************************
             -***
   8          //  Website: http://www.nuvoton.com
   9          //  E-Mail : MicroC-8bit@nuvoton.com
  10          //  Date   : Jan/21/2017
  11          //********************************************************************************************************
             -***
  12          
  13          //********************************************************************************************************
             -***
  14          //  File Function: N76E003 GPIO demo code
  15          //********************************************************************************************************
             -***
  16          #include "N76E003.h"
  17          #include "SFR_Macro.h"
  18          #include "Function_define.h"
  19          #include "Common.h"
  20          #include "Delay.h"
  21          #include "stdio.h"
  22          #include "string.h"
  23          #include "stdlib.h"
  24          
  25          
  26          #define HIGH 1
  27          #define LOW 0
  28          
  29          #define WAITING 2
  30          #define PLAYING 1
  31          #define STOP 0
  32          #define ON 1
  33          #define OFF 0
  34          #define MINIT   60
  35          #define SECOND 1
  36          #define SW_PRESS 1
  37          #define SW_RELEASE 2
  38          #define SW_NONE 0
  39          
  40          
  41          /*------------------------------------------------
  42          The main C function.  Program execution starts
  43          here after stack initialization.
  44          ------------------------------------------------*/
  45          
C51 COMPILER V9.53.0.0   LITTLE_CAR                                                        06/21/2018 21:33:24 PAGE 2   

  46          #define setbit(x,y) x|=(1<<y) //将X的第Y位置1
  47          #define testbit(x,y) x&(1<<y) //测试X的第Y位置
  48          #define clrbit(x,y) x&=!(1<<y) //将X的第Y位清0
  49          
  50          #if 1
  51          uchar button_trig_state=LOW;
  52          uchar Button_state=HIGH;
  53          void PinInterrupt_ISR (void) interrupt 7
  54          {
  55   1        if (testbit(PIF,4)) //SWITCH PIN
  56   1        {
  57   2          clrbit(PIF,4);
  58   2          //Delay_100us(1);
  59   2          if(button_trig_state==LOW && P14==LOW){
  60   3            Enable_BIT4_RasingEdge_Trig;
  61   3            button_trig_state=HIGH;
  62   3            Button_state=LOW;
  63   3            Send_Data_To_UART0(Button_state);
  64   3            Send_Data_To_UART0('\n');
  65   3            Send_Data_To_UART0(Button_state);
  66   3            Send_Data_To_UART0('\n');
  67   3          }else if(button_trig_state==HIGH && P14==HIGH){
  68   3            Enable_BIT4_FallEdge_Trig;
  69   3            button_trig_state=LOW;
  70   3            Button_state=HIGH;
  71   3            Send_Data_To_UART0(Button_state);
  72   3            Send_Data_To_UART0('\n');
  73   3            Send_Data_To_UART0(Button_state);
  74   3            Send_Data_To_UART0('\n');
  75   3          }
  76   2        }
  77   1      }
  78          #endif
  79          
  80          int Send_num(int num){
  81   1        char CharToSend[10];
  82   1        uchar i=0,j=9;
  83   1        uchar negative=0;
  84   1        if(num<0){
  85   2          negative=1;
  86   2          num=-num;
  87   2        }
  88   1        if(num==0)
  89   1          CharToSend[j--]='0';
  90   1        while(num>0){
  91   2          uchar aa=num%10;
  92   2          CharToSend[j--]='0'+aa;
  93   2          num=num/10;
  94   2        }
  95   1        if(negative==1){
  96   2          CharToSend[j--]='-';
  97   2        }
  98   1        for(i=j+1; i<10; i++){
  99   2          Send_Data_To_UART1(CharToSend[i]);
 100   2        }
 101   1      }
 102          /*********************************************************************************************************
             -***
 103          *     Servo Control part
 104          **********************************************************************************************************
             -**/
 105          //9C3F=40000;
C51 COMPILER V9.53.0.0   LITTLE_CAR                                                        06/21/2018 21:33:24 PAGE 3   

 106          //MIN=1000=0X03E8;
 107          //MIDDLE=3000=0X0BB8
 108          //MAX=5000=0X1388;
 109          #define RATE 2
 110          #define SERVO_LEFT    1000
 111          #define SERVO_RIGHT   5000
 112          #define SERVO_MIDDLE  3000
 113          #define SEVOR_PIN     P10
 114          #define TIMER_DIV12_VALUE_50us      65536-65    //65*12/16000000 = 50 uS,     // Timer divider = 12 
 115          
 116          int timer_count=0;
 117          int servo_angle=15*RATE;
 118          #if 0
              void Servo_Timer0_ISR (void) interrupt 1          //interrupt address is 0x000B
              {
                clr_TF0;
                clr_TR0;                                    //Stop Timer0
                  TL0 = LOBYTE(TIMER_DIV12_VALUE_50us);     //Find  define in "Function_define.h" "TIMER VALUE"
                  TH0 = HIBYTE(TIMER_DIV12_VALUE_50us);
                set_TR0;                                    //Start Timer0
                if(timer_count<=servo_angle){
                  SEVOR_PIN=1;
                }else{
                  SEVOR_PIN=0;
                }
                timer_count++;
                if(timer_count>=200*RATE){
                  timer_count=0;
                  Send_Data_To_UART0(Button_state);
                  Send_Data_To_UART0('\n');
                }
              }
              #endif
 139          void Init_servo(){
 140   1      
 141   1      #if 0
                P10_PushPull_Mode;              //Servo control pin
                
                TIMER0_MODE0_ENABLE;                        //Timer 0 and Timer 1 mode configuration
                clr_T0M;
                  TMOD |= 0x01;                               //Timer0 is 16-bit mode
                  TL0 = LOBYTE(TIMER_DIV12_VALUE_10ms);     //Find  define in "Function_define.h" "TIMER VALUE"
                  TH0 = HIBYTE(TIMER_DIV12_VALUE_10ms);
                set_ET0;                                    //enable Timer0 interrupt
                set_TR0;                                    //Timer0 run
              #endif
 152   1      }
 153          
 154          int set_angle(int angle){
 155   1        angle+=90;  //angle range -90~90
 156   1        if(angle<0){
 157   2          angle=0;
 158   2        }
 159   1        if(angle>180){
 160   2          angle=180;
 161   2        }
 162   1        servo_angle=SERVO_LEFT+((float)(SERVO_RIGHT-SERVO_LEFT))/180*angle;
 163   1        PWM2H = HIBYTE(servo_angle);      //L9110 PWM 0
 164   1        PWM2L = LOBYTE(servo_angle);
 165   1        set_LOAD;
 166   1        return angle-90;
 167   1      }
C51 COMPILER V9.53.0.0   LITTLE_CAR                                                        06/21/2018 21:33:24 PAGE 4   

 168          /*********************************************************************************************************
             -***
 169          *     Motor Control
 170          **********************************************************************************************************
             -**/
 171          #define SPEED_MIN   3999
 172          #define SPEED_MAX   39999
 173          
 174          int Motor_move(int speed){      //speed range -10~10
 175   1        int speed_load=0;
 176   1        if(speed>10){
 177   2          speed=10;
 178   2        }
 179   1        if(speed<-10){
 180   2          speed=-10;
 181   2        }
 182   1        //speed=speed*200;
 183   1        if(speed==0){
 184   2          PWM0H = HIBYTE(0);    //L9110 PWM HIGH
 185   2          PWM0L = LOBYTE(0);
 186   2          PWM1H = HIBYTE(0);      //L9110 PWM 0   
 187   2          PWM1L = LOBYTE(0);
 188   2        }
 189   1        if(speed>0){
 190   2          speed_load=(SPEED_MAX-SPEED_MIN)/10*speed+SPEED_MIN;
 191   2          PWM0H = HIBYTE(speed_load);   //L9110 PWM HIGH
 192   2          PWM0L = LOBYTE(speed_load);
 193   2          PWM1H = HIBYTE(0);      //L9110 PWM 0   
 194   2          PWM1L = LOBYTE(0);
 195   2        }
 196   1        if(speed<0){
 197   2          speed=-speed;
 198   2          speed_load=(SPEED_MAX-SPEED_MIN)/10*speed+SPEED_MIN;
 199   2          PWM0H = HIBYTE(0);      //L9110 PWM 0
 200   2          PWM0L = LOBYTE(0);
 201   2          PWM1H = HIBYTE(speed_load);   //L9110 PWM HIGH    
 202   2          PWM1L = LOBYTE(speed_load);
 203   2        }
 204   1        //PWM0_OUTPUT_INVERSE;
 205   1        set_LOAD;
 206   1        return speed;
 207   1      }
 208          void Init_motor(){
 209   1        PWM0_P12_OUTPUT_ENABLE;
 210   1        PWM1_P11_OUTPUT_ENABLE;
 211   1      
 212   1        PWM_IMDEPENDENT_MODE;
 213   1        
 214   1        PWM2_P10_OUTPUT_ENABLE;
 215   1        PWM_CLOCK_DIV_8;
 216   1        PWMPH = 0x9C;             //Setting PWM period
 217   1        PWMPL = 0x3F;
 218   1        
 219   1        PWM0H = 0x0B;             //PWM0 high duty = 1/2 PWM period
 220   1        PWM0L = 0xB8; 
 221   1      
 222   1        set_LOAD;
 223   1        set_PWMRUN;
 224   1      }
 225          
 226          //-----------------------------------------------------------------------------------
 227          #define STR_LIMIT   50
C51 COMPILER V9.53.0.0   LITTLE_CAR                                                        06/21/2018 21:33:24 PAGE 5   

 228          char Tmp_Buf[STR_LIMIT];
 229          char Str_Buf[STR_LIMIT];
 230          int Write_Num=0;
 231          int Read_Num=0;
 232          int Str_Ready=0;
 233          int Data_Ready=0;
 234          
 235          #if 0
              uchar get_string()
              {
                  int result_num=0;
                int timeout=100;
              
                while(!RI && timeout--){
                  Delay_100us(1);   //delay 25ms
                }
                  while (RI) {
                    Str_Buf[result_num++]=SBUF;
                  RI = 0;
                  if(result_num>=STR_LIMIT){
                    break;
                  }
                  timeout=5000;
                  while(!RI && timeout--);
                  }
                Str_Buf[result_num]=0;
                  return result_num;
              }
              #else
 257          int get_string(){
 258   1        int str_count=0;
 259   1        while(Tmp_Buf[Read_Num]){
 260   2          Str_Buf[str_count]=Tmp_Buf[Read_Num];
 261   2          Tmp_Buf[Read_Num]=0;
 262   2          str_count++;
 263   2          Read_Num++;
 264   2          if(Read_Num>=STR_LIMIT){
 265   3            Read_Num=0;
 266   3          }
 267   2          if(Str_Buf[str_count-1]=='\n'){
 268   3            break;
 269   3          }
 270   2        }
 271   1        Str_Buf[str_count]=0;
 272   1        return str_count;
 273   1      }
 274          
 275          void SerialPort0_ISR(void) interrupt 4 
 276          {
 277   1          if (RI==1) 
 278   1          {                                       /* if reception occur */
 279   2              clr_RI;                             /* clear reception flag for next reception */
 280   2              Tmp_Buf[Write_Num] = SBUF;
 281   2          Write_Num++;
 282   2          if(Write_Num>=STR_LIMIT){
 283   3            Write_Num=0;
 284   3          }
 285   2          }
 286   1      }
 287          #endif
 288          
 289          void StrTrim(char*pStr)  
C51 COMPILER V9.53.0.0   LITTLE_CAR                                                        06/21/2018 21:33:24 PAGE 6   

 290          {  
 291   1          char *pTmp = pStr;  
 292   1            
 293   1          while (*pStr != 0)   
 294   1          {  
 295   2              if (*pStr != ' ')  
 296   2              {  
 297   3                  *pTmp++ = *pStr;  
 298   3              }  
 299   2              ++pStr;  
 300   2          }  
 301   1          *pTmp = 0;  
 302   1      } 
 303          
 304          
 305          
 306          void main (void) 
 307          {
 308   1        //set_PD;
 309   1        Set_All_GPIO_Quasi_Mode;          // Define in Function_define.h
 310   1        //DEBUG_LED=0;
 311   1        InitialUART0_Timer1(115200);
 312   1        InitialUART1_Timer3(115200);
 313   1      /*---------------------------------------------------------------*/
 314   1        P14_Input_Mode;
 315   1      #if 1
 316   1        set_P0S_4;
 317   1        Enable_BIT4_FallEdge_Trig;
 318   1        button_trig_state=LOW;
 319   1        Enable_INT_Port1; 
 320   1      #endif
 321   1      /*---------------------------------------------------------------*/
 322   1        set_EA;                                     //enable interrupts
 323   1        set_EPI;
 324   1        set_ES;
 325   1      /*---------------------------------Main function-----------------------------------------------*/
 326   1        Init_motor();
 327   1        Init_servo();
 328   1        set_angle(0);
 329   1        Motor_move(0);
 330   1        while(1){
 331   2          int count = get_string();
 332   2          //printf("get string\n");
 333   2          if(count>0){
 334   3            int speed=0, angle=0;
 335   3            char speed_str[8],angle_str[8];
 336   3            char * dot_pos;
 337   3            //printf("get:%s",Str_Buf);
 338   3            count = strlen(Str_Buf);
 339   3            dot_pos=strchr(Str_Buf,',');
 340   3            if(dot_pos!=NULL){
 341   4              memset(speed_str,0,sizeof(speed_str));
 342   4              memset(angle_str,0,sizeof(angle_str));
 343   4              strncpy(speed_str,Str_Buf,dot_pos-Str_Buf);
 344   4              strncpy(angle_str,dot_pos+1,count-(dot_pos-Str_Buf)-1);
 345   4              StrTrim(speed_str);
 346   4              StrTrim(angle_str);
 347   4              speed=atoi(speed_str);
 348   4              angle=atoi(angle_str);
 349   4              if(speed>=-10 && speed<=10)
 350   4                speed=Motor_move(speed);
 351   4              else
C51 COMPILER V9.53.0.0   LITTLE_CAR                                                        06/21/2018 21:33:24 PAGE 7   

 352   4                speed=200;
 353   4              if(angle>=-90 && angle<=90)
 354   4                angle=set_angle(angle);
 355   4              else
 356   4                angle=400;
 357   4              //printf("set:%d,%d\n",speed,angle);
 358   4            }
 359   3            
 360   3          }
 361   2        }
 362   1      }
*** WARNING C290 IN LINE 101 OF Code\Little_Car.C: missing return value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1690    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    114      51
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
